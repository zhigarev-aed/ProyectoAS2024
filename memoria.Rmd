---
title: "Eliminación de ruido en imágenes con wavelets."
subtitle: "Análisis de señales"
author: "Grupo E: Alejandra Venegas, Rebeca Company, Marta Medina, Alejandro Cornelio y Ilia Zhigarev."
date: "`r Sys.Date()`"
output:
  bookdown::pdf_document2:
    toc: true
    toc_depth: 3
    number_sections: true
    figure_caption: "Figura" # Referencias en castellano
    table_caption: "Tabla"
  html_document:
    echo: true
    number_sections: true
    theme: lumen
    toc: true
  html_notebook:
    echo: true
    number_sections: true
    toc: true
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
  bookdown::html_document2:
    echo: true
    number_sections: true
    theme: spacelab
    toc: true
    figure_caption: "Figura"
    table_caption: "Tabla"
always_allow_html: true
params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm (list=ls())
```

# Introducción

# Fundamento teórico: eliminación de ruido con wavelets

# Funciones de programacion empleadas

# Desarrollo y resultados


Antes de comenzar, instalamos y/o cargamos todos los paquetes requeridos.
```{r, message = FALSE}
if (!require("pacman")) install.packages("pacman")
library(pacman)
p_load(imager, wavethresh, ggplot2, dplyr, SpatialPack, waveslim, EBImage, stringr, jpeg, abind, magick)
```

Comenzamos cargando y visualizando las fotografías a emplear.
```{r}
images_path <- list.files("./fotos", full.names = TRUE)

nombres_images <- str_remove_all(string = str_remove_all(string = images_path, pattern = "./fotos/"), pattern = "\\.JPG|\\.jpg")

images <- lapply(images_path, readJPEG) # Cargamos las imágenes

names(images) <- nombres_images
```

```{r}
# Rotamos algunas de las fotos para una visualización más uniforme
fotos_a_girar <- c("1", "2", "3", "4")
images_rotadas <- lapply(images[fotos_a_girar], aperm, perm = c(2, 1, 3))


for (i in fotos_a_girar) {
  images_rotadas[[i]] < images_rotadas[[i]][dim(images_rotadas[[i]])[1]:1, , ]
}

images[fotos_a_girar] <- images_rotadas
rm(images_rotadas)
rm(fotos_a_girar)
```


```{r}
# Visualizamos las imagenes originales (comento para que no tarde en ejecutar)

#par(mfrow = c(2, 3), mar = c(1, 1, 1, 1))

# for (img in nombres_images) {
#   display(Image(images[[img]], colormode = "Color"), method = "r")
#   title(paste('Imagen', img))
# }
```

## Inclusión de ruido sintético en las imágenes

```{r, fig.height = 4}
# Definición de tipos de ruido

NOISE_TYPES <- list(
  gaussian = list(
    generator = function(channel, params) {
      # Desviación estándar del ruido con un valor predeterminado
      noise_std_dev <- params$std_dev %||% 0.5

      # Generación de ruido gaussiano
      noise <- array(
        rnorm(length(channel), mean = 0, sd = noise_std_dev),
        dim = dim(channel)
      )

      # Asegurar que los valores estén entre 0 y 1
      pmax(0, pmin(1, channel + noise))
    }
  ),
  sinusoidal_high = list(
    generator = function(channel, params) {
      # Frecuencia y amplitud del ruido sinusoidal de alta frecuencia
      frequency <- params$frequency %||% 25
      amplitude <- params$amplitude %||% 0.2

      # Generación de ruido sinusoidal
      height <- dim(channel)[1]
      width <- dim(channel)[2]
      x <- seq(0, 2 * pi, length.out = width)
      y <- seq(0, 2 * pi, length.out = height)
      noise_grid <- outer(sin(x * frequency), sin(y * frequency))

      # Aplicar el ruido
      noise <- array(noise_grid * amplitude, dim = dim(channel))
      pmax(0, pmin(1, channel + noise))
    }
  ),
  sinusoidal_low = list(
    generator = function(channel, params) {
      # Frecuencia y amplitud del ruido sinusoidal de baja frecuencia
      frequency <- params$frequency %||% 2
      amplitude <- params$amplitude %||% 0.2

      # Generación de ruido sinusoidal
      height <- dim(channel)[1]
      width <- dim(channel)[2]
      x <- seq(0, 2 * pi, length.out = width)
      y <- seq(0, 2 * pi, length.out = height)
      noise_grid <- outer(sin(x * frequency), sin(y * frequency))

      # Aplicar el ruido
      noise <- array(noise_grid * amplitude, dim = dim(channel))
      pmax(0, pmin(1, channel + noise))
    }
  ),
  salt_pepper = list(
    generator = function(channel, params) {
      # Proporción de píxeles afectados por el ruido de sal y pimienta
      epsilon <- params$epsilon %||% 0.2

      # Generación de ruido
      noise <- matrix(sample(c(0, 1, NA), length(channel), replace = TRUE, prob = c(epsilon / 2, epsilon / 2, 1 - epsilon)),
        nrow = dim(channel)[1], ncol = dim(channel)[2]
      )
      channel[!is.na(noise)] <- noise[!is.na(noise)]
      channel
    }
  ),
  gamma = list(
    generator = function(channel, params) {
      # Ruido multiplicativo gamma con parámetro de dispersión
      looks <- params$looks %||% 2
      noise <- array(rgamma(length(channel), shape = looks, scale = 1 / looks), dim = dim(channel))
      pmax(0, pmin(1, channel * noise))
    }
  ),
  uniform_multiplicative = list(
    generator = function(channel, params) {
      # Ruido multiplicativo uniforme
      looks <- params$looks %||% 2
      noise_channel <- SpatialPack::imnoise(
        img = channel,
        type = "speckle",
        looks = looks
      )
      pmax(0, pmin(1, noise_channel))
    }
  )
)
```


```{r, fig.height = 4}
# Función para añadir ruido a una imagen
add_noise_to_image <- function(image_name, noise_type, noise_params = list(), plot = FALSE) {
  # Verificar si la imagen existe en la lista
  if (!image_name %in% names(images)) {
    stop("La imagen con este nombre no se encuentra en la lista 'images'")
  }

  # Verificar el tipo de ruido
  if (!noise_type %in% names(NOISE_TYPES)) {
    stop(
      "El tipo de ruido es desconocido. Tipos disponibles: ",
      paste(names(NOISE_TYPES), collapse = ", ")
    )
  }

  # Obtener la imagen original de la lista
  original_image <- images[[image_name]]

  # Convertir la imagen a un array si es necesario
  image_array <- as.array(original_image)

  # Aplicar ruido a cada canal
  noisy_channels <- lapply(1:3, function(i) {
    channel <- image_array[, , i]
    NOISE_TYPES[[noise_type]]$generator(channel, noise_params)
  })

  # Crear la imagen con ruido
  noisy_image_array <- array(
    unlist(noisy_channels),
    dim = dim(image_array)
  )

  # Visualizar si se ha indicado
  if (plot == TRUE){
  layout(matrix(1:2, 1, 2))
  plot(Image(original_image, colormode = "Color"))
  title("Original")
  plot(Image((noisy_image_array), colormode = "Color"))
  title(paste("Ruido:", noise_type))}
  
  return(noisy_image_array)
}
```


```{r, fig.height = 4}
# Aplicar los diferentes tipos de ruido a cada imagen
# add_noise_to_image("1", "gaussian", list(std_dev = 0.3))
# add_noise_to_image("2", "sinusoidal_high", list(frequency = 25, amplitude = 0.2))
# add_noise_to_image("3", "sinusoidal_low", list(frequency = 2, amplitude = 0.2))
# add_noise_to_image("4", "salt_pepper", list(epsilon = 0.1))
# add_noise_to_image("5", "gamma", list(looks = 2))
# add_noise_to_image("5", "uniform_multiplicative", list(looks = 2))
```



## Función imwd

### Redimensionando las imágenes

Como ya se ha visto (INCLUIR!!!!!!) para poder aplicar la función `imwd()`es necesario partir de una matriz cuadrada cuyas dimensiones sean potencia de dos. Por ello, en primer lugar creamos una función `resize_imwd()` tal que dada una foto busca la submatriz cuadrada y potencia de dos más grande posible y a continuacón redimensiona la imagen a dicha submatriz cuadrada.

 
```{r}
# Pre-procesamiento al aplicado de función imwd (algoritmo de Mallat).Recortado de imagen.

# recortar_imwd<- function(foto){
#   
#   # Dimensiones de la foto
#   dim_foto <- dim(foto)
#   filas <- dim_foto[1]
#   columnas <- dim_foto[2]
#   
#   lado_minimo <- min(filas, columnas)  # Tamaño submatriz cuadrada mas grande
#   lado_potencia2 <- 2^floor(log2(lado_minimo)) # Tamaño submatriz cuadrada potencia de dos mas grande
#   
#   # Recortar la foto en la zona central
#   
#   # Calculo de los indices iniciales
#   if (filas %% 2 == 0){
#    # Si el numero de filas es par
#   filas_begin <- (filas/2) +1 - (lado_potencia2/2)
#   }
#   else { # Si el numero de filas es impar
#     filas_begin <-(filas+1)/2 - (lado_potencia2/2)
#   }
#   
#   if (columnas %% 2 == 0){
#    # Si el numero de columnas es par
#   col_begin <- (columnas/2) + 1 - (lado_potencia2/2)
#   } else { # Si el numero de columnas es impar
#     col_begin <-(columnas+1)/2 - (lado_potencia2/2)
#   }
#   
#   # Calculo de los indices finales
#   filas_end <- filas_begin + lado_potencia2 -1
#   col_end <- col_begin + lado_potencia2 -1
# 
# # Extraer la submatriz cuadrada centrada
# foto_cuadrada_centrada <- foto[filas_begin:filas_end, col_begin:col_end, ]
# # Si no se desea la submatriz centrada se puede modificar la funcion.
# return(foto_cuadrada_centrada)
# }
```

```{r}
# Pre-procesamiento al aplicado de función imwd (algoritmo de Mallat).
# Redimensionamiento de la imagen 

resize_imwd<- function(foto){
  
  img <- as.cimg(foto) # Pasar a formato Imager para aplicar función resize
   
  # Dimensiones de la foto
  dim_foto <- dim(foto)
  filas <- dim_foto[1]
  columnas <- dim_foto[2]
  
  lado_minimo <- min(filas, columnas)  # Tamaño submatriz cuadrada mas grande
  lado_potencia2 <- 2^floor(log2(lado_minimo)) # Tamaño submatriz cuadrada potencia de dos mas grande
  
  foto_resized <-resize(foto, w = lado_potencia2, h = lado_potencia2) # Redimensionado de la imagen

return(foto_resized)
}
```


Para comenzar, vamos a emplear dos imágenes muy parecidas (imágenes 4 y 5). Una de ellas tiene muy alta resolución mientras que la segunda cuenta con una calidad mucho menor. El objetivo es determinar si la resolución de la imagen afecta a la hora de eliminar ruido de esta.

```{r}
# Añadimos ruido gaussiano a las imágenes con sd = 0.3
image_4_gaussian_noise <- add_noise_to_image("4", "gaussian", list(std_dev = 0.3))
image_5_gaussian_noise <- add_noise_to_image("5", "gaussian", list(std_dev = 0.3))

# Hacemos una lista con las imágenes con ruido a redimensionar
images_for_imwd_cut_1 <- list(image_4_gaussian_noise, image_5_gaussian_noise)
names(images_for_imwd_cut_1) <- c('4 Noise: gaussian', '5 Noise: gaussian')

# Eliminamos variables innecesarias
rm(image_4_gaussian_noise)
rm(image_5_gaussian_noise)
```



```{r}
# Añadimos ruido a imágenes (segunga prueba)
# image_1_gaussian_noise <- add_noise_to_image("1", "gaussian", list(std_dev = 0.5))
# image_2_sinosuidal_high <- add_noise_to_image("2", "sinusoidal_high", list(frequency = 50, amplitude = 0.3))
# image_3_sinosoidal_low <- add_noise_to_image("3", "sinusoidal_low", list(frequency = 5, amplitude = 0.2))
# #image_4_salt_pepper <- add_noise_to_image("4", "salt_pepper", list(epsilon = 1))
# #image_5_gamma <- add_noise_to_image("5", "gamma", list(looks = 2))
# # add_noise_to_image("5", "uniform_multiplicative", list(looks = 2))
# 
# 
# # Hacemos una lista con las imágenes con ruido a recortar
# images_for_imwd_cut <- list(image_1_gaussian_noise, image_2_sinosuidal_high, image_3_sinosoidal_low)
# names(images_for_imwd_cut) <- c('1 Noise: gaussian', '2 Noise: sinusoidal high', '3 Noise: sinusoidal low')
# 
# # Eliminamos variables innecesarias
# rm(image_1_gaussian_noise)
# rm(image_2_sinosuidal_high)
# rm(image_3_sinosoidal_low)
#rm(image_4_salt_pepper)
#rm(image_5_gamma)
```


```{r}
images_recortadas <- lapply(images_for_imwd_cut_1, resize_imwd)

```

```{r}
 # Visualizamos las imágenes redimensionadas
# par(mfrow = c(1, 3), mar = c(1, 1, 1, 1))
# 
# for (img in names(images_recortadas_1)){
# display(Image(images_recortadas_1[[img]], colormode = 'Color'), method='r')
# }
```


```{r}
# Transformada wavalet a las imágenes con ruido redimensionadas
lwd <- lapply(images_recortadas, function(foto) { 
  lapply(1:3, function(canal) {
    wavethresh::imwd(foto[,,canal]) # Aplicamos la transformada wavelet a cada canal
  })
})
```


```{r}
# Aplicamos threshold. Parámetros elegidos:
type <- "hard"
policy <- "universal"


lwd_threshold <- lapply(lwd, 
function(lwd){
  lapply(1:3, function(canal){
    niveles <- lwd[[canal]]$nlevels
  wavethresh::threshold(lwd[[canal]], levels = 3:(niveles-1), type = type, policy = policy)
  })
})
```


```{r}
# Transformada wavelet inversa
ilwd <- lapply(lwd_threshold, function(foto) { 
  lapply(1:3, function(canal) {
    wavethresh::imwr(foto[[canal]]) # Aplicamos la transformada wavelet inversa a cada canal
  })
})

```

```{r}
# Transformamos al formato origial (imagenes como matrices [n,m,3])
ilwd_matriz <- lapply(ilwd, function(foto) {
  abind::abind(foto[[1]], foto[[2]], foto[[3]], along = 3)
})

```


```{r}
 # Visualizamos las imágenes 
par(mfrow = c(2, 3), cex = 0.5)

#display(Image(images_recortadas_orginales[[1]], colormode = 'Color'), method='r')
display(Image(images[[4]], colormode = 'Color'), method='r')
title('Imagen 4 original')
display(Image(images_recortadas[[1]], colormode = 'Color'), method='r')
title('Imagen 4 con ruido')
display(Image(ilwd_matriz[[1]], colormode = 'Color'), method='r')
title('Imagen 4 sin ruido')

display(Image(images[[5]], colormode = 'Color'), method='r')
title('Imagen 5 original')
display(Image(images_recortadas[[2]], colormode = 'Color'), method='r')
title('Imagen 5 con ruido')
display(Image(ilwd_matriz[[2]], colormode = 'Color'), method='r')
title('Imagen 5 sin ruido')


```

Observamos que la imagen 4, que originalmente tenía una mucha mayor resolución presenta una menor distorsión tras la eliminación de ruido que la fotografía con menor resolución (menor número de píxeles).


A continuación vamos a comprobar que es lo que ocurre cuando añadimos ruido sintético sinusoidal y si la frecuencia de este afecta al resultado de la eliminación de ruido. Trabajaremos con una única fotografía: la imagen 1.

```{r}
# Añadimos ruido sinusoidal a las imágenes con sd = 0.3
image_1_sinosuidal_high <- add_noise_to_image("1", "sinusoidal_high", list(frequency = 50, amplitude = 0.3))
image_1_sinosuidal_low <- add_noise_to_image("2", "sinusoidal_high", list(frequency = 5, amplitude = 0.3))

# Hacemos una lista con las imágenes con ruido a redimensionar
images_for_imwd_cut_2 <- list(image_1_sinosuidal_high , image_1_sinosuidal_low )
names(images_for_imwd_cut_1) <- c('1 Noise: sinusoidal high', '1 Noise: sinusoidal low')

# Eliminamos variables innecesarias
rm(image_1_sinosuidal_high)
rm(image_1_sinosuidal_low)
```

```{r}
images_recortadas <- lapply(images_for_imwd_cut_2, resize_imwd)


# Transformada wavalet a las imágenes con ruido redimensionadas
lwd <- lapply(images_recortadas, function(foto) { 
  lapply(1:3, function(canal) {
    wavethresh::imwd(foto[,,canal]) # Aplicamos la transformada wavelet a cada canal
  })
})

# Aplicamos threshold. Parámetros elegidos:
type <- "hard"
policy <- "universal"


lwd_threshold <- lapply(lwd, 
function(lwd){
  lapply(1:3, function(canal){
    niveles <- lwd[[canal]]$nlevels
  wavethresh::threshold(lwd[[canal]], levels = 3:(niveles-1), type = type, policy = policy)
  })
})

# Transformada wavelet inversa
ilwd <- lapply(lwd_threshold, function(foto) { 
  lapply(1:3, function(canal) {
    wavethresh::imwr(foto[[canal]]) # Aplicamos la transformada wavelet inversa a cada canal
  })
})


# Transformamos al formato origial (imagenes como matrices [n,m,3])
ilwd_matriz <- lapply(ilwd, function(foto) {
  abind::abind(foto[[1]], foto[[2]], foto[[3]], along = 3)
})

```


```{r}
 # Visualizamos 
par(mfrow = c(2, 3), cex = 0.5)

#display(Image(images_recortadas_orginales[[1]], colormode = 'Color'), method='r')
display(Image(images[[1]], colormode = 'Color'), method='r')
title('Imagen 1 original')
display(Image(images_recortadas[[1]], colormode = 'Color'), method='r')
title('Frecuencia alta')
display(Image(ilwd_matriz[[1]], colormode = 'Color'), method='r')
title('Imagen 1 sin ruido')

display(Image(images[[1]], colormode = 'Color'), method='r')
title('Imagen 1 original')
display(Image(images_recortadas[[2]], colormode = 'Color'), method='r')
title('Frecuencia baja')
display(Image(ilwd_matriz[[2]], colormode = 'Color'), method='r')
title('Imagen 1 sin ruido')


```
Probamos otros tipos de ruido: gamma, salt and pepper... en las imágenes 2 y 3. 
```{r}
# Añadimos ruido a imágenes
image_2_salt_pepper <- add_noise_to_image("2", "salt_pepper", list(epsilon = 0.1))
image_3_gamma <- add_noise_to_image("3", "gamma", list(looks = 2))
image_3_uniform <- add_noise_to_image("3", "uniform_multiplicative", list(looks = 2))


# Hacemos una lista con las imágenes con ruido a recortar
images_for_imwd_cut_3 <- list( image_2_salt_pepper, image_3_gamma, image_3_uniform)
names(images_for_imwd_cut_3) <- c('2 Noise: salt and pepper', '3 Noise: gamma','3 Noise: uniform')

# Eliminamos variables innecesarias
rm(image_2_salt_pepper, image_3_gamma, image_3_uniform)

```

```{r}
images_recortadas <- lapply(images_for_imwd_cut_3, resize_imwd)


# Transformada wavalet a las imágenes con ruido redimensionadas
lwd <- lapply(images_recortadas, function(foto) { 
  lapply(1:3, function(canal) {
    wavethresh::imwd(foto[,,canal]) # Aplicamos la transformada wavelet a cada canal
  })
})

# Aplicamos threshold. Parámetros elegidos:
type <- "hard"
policy <- "universal"


lwd_threshold <- lapply(lwd, 
function(lwd){
  lapply(1:3, function(canal){
    niveles <- lwd[[canal]]$nlevels
  wavethresh::threshold(lwd[[canal]], levels = 3:(niveles-1), type = type, policy = policy)
  })
})

# Transformada wavelet inversa
ilwd <- lapply(lwd_threshold, function(foto) { 
  lapply(1:3, function(canal) {
    wavethresh::imwr(foto[[canal]]) # Aplicamos la transformada wavelet inversa a cada canal
  })
})


# Transformamos al formato origial (imagenes como matrices [n,m,3])
ilwd_matriz <- lapply(ilwd, function(foto) {
  abind::abind(foto[[1]], foto[[2]], foto[[3]], along = 3)
})

```

```{r}
 # Visualizamos las imágenes
par(mfrow = c(4, 3), cex = 0.5, mar = c(3,1,3,1))



display(Image(images[[2]], colormode = 'Color'), method='r')
title('Imagen 2 original')
display(Image(images_recortadas[[1]], colormode = 'Color'), method='r')
title('Salt and pepper')
display(Image(ilwd_matriz[[1]], colormode = 'Color'), method='r')
title('Imagen 2 sin ruido')

display(Image(images[[3]], colormode = 'Color'), method='r')
title('Imagen 3 original')
display(Image(images_recortadas[[2]], colormode = 'Color'), method='r')
title('Gamma')
display(Image(ilwd_matriz[[2]], colormode = 'Color'), method='r')
title('Imagen 3 sin ruido')


display(Image(images[[3]], colormode = 'Color'), method='r')
title('Imagen 3 original')
display(Image(images_recortadas[[3]], colormode = 'Color'), method='r')
title('Uniform')
display(Image(ilwd_matriz[[3]], colormode = 'Color'), method='r')
title('Imagen 3 sin ruido')

```
## Función denoise...

# Conclusiones
