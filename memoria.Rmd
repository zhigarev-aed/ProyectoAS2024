---
title: "Eliminación de ruido en imágenes con wavelets."
subtitle: "Análisis de señales"
author: "Grupo E: Alejandra Venegas, Rebeca Company, Marta Medina, Alejandro Cornelio y Ilia Zhigarev."
date: "`r Sys.Date()`"
output:
  html_document:
    echo: true
    number_sections: true
    theme: lumen
    toc: true
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
  bookdown::pdf_document2:
    toc: true
    toc_depth: 3
    number_sections: true
    figure_caption: "Figura" # Referencias en castellano
    table_caption: "Tabla"
  html_notebook:
    echo: true
    number_sections: true
    toc: true
  bookdown::html_document2:
    echo: true
    number_sections: true
    theme: spacelab
    toc: true
    figure_caption: "Figura"
    table_caption: "Tabla"
always_allow_html: true
params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

# Introducción

# Fundamento teórico: eliminación de ruido con wavelets

# Funciones de programacion empleadas

# Desarrollo y resultados

Antes de comenzar, instalamos y/o cargamos todos los paquetes requeridos.
```{r, message = FALSE}
if (!require("pacman")) install.packages("pacman")
library(pacman)
p_load(imager, wavethresh, ggplot2, dplyr, SpatialPack, waveslim, EBImage, stringr, jpeg)
```

Comenzamos cargando y visualizando las fotografías a emplear.
```{r}
images_path <- list.files("./fotos", full.names = TRUE)

nombres_images <- str_remove_all(string = str_remove_all(string = images_path, pattern = "./fotos/"), pattern = "\\.JPG|\\.jpg")

images <- lapply(images_path, readJPEG) # Cargamos las imágenes

# Nota: cambie de load.image a readJPEG pq asi ya no hace falta usar el drop para quitar lo de cimg, sale bien directamente
names(images) <- nombres_images
```

```{r}
# Rotamos algunas de las fotos para una visualización más uniforme
fotos_a_girar <- c("1", "2", "3", "4")
images_rotadas <- lapply(images[fotos_a_girar], aperm, perm = c(2, 1, 3))


for (i in fotos_a_girar) {
  images_rotadas[[i]] < images_rotadas[[i]][dim(images_rotadas[[i]])[1]:1, , ]
}

images[fotos_a_girar] <- images_rotadas
rm(images_rotadas)
rm(fotos_a_girar)
```




## Inclusión de ruido sintético en las imágenes

```{r, fig.height = 4}
# Definición de tipos de ruido

NOISE_TYPES <- list(
  gaussian = list(
    generator = function(channel, params) {
      # Desviación estándar del ruido con un valor predeterminado
      noise_std_dev <- params$std_dev %||% 0.5

      # Generación de ruido gaussiano
      noise <- array(
        rnorm(length(channel), mean = 0, sd = noise_std_dev),
        dim = dim(channel)
      )

      # Asegurar que los valores estén entre 0 y 1
      pmax(0, pmin(1, channel + noise))
    }
  ),
  sinusoidal_high = list(
    generator = function(channel, params) {
      # Frecuencia y amplitud del ruido sinusoidal de alta frecuencia
      frequency <- params$frequency %||% 25
      amplitude <- params$amplitude %||% 0.2

      # Generación de ruido sinusoidal
      height <- dim(channel)[1]
      width <- dim(channel)[2]
      x <- seq(0, 2 * pi, length.out = width)
      y <- seq(0, 2 * pi, length.out = height)
      noise_grid <- outer(sin(x * frequency), sin(y * frequency))

      # Aplicar el ruido
      noise <- array(noise_grid * amplitude, dim = dim(channel))
      pmax(0, pmin(1, channel + noise))
    }
  ),
  sinusoidal_low = list(
    generator = function(channel, params) {
      # Frecuencia y amplitud del ruido sinusoidal de baja frecuencia
      frequency <- params$frequency %||% 2
      amplitude <- params$amplitude %||% 0.2

      # Generación de ruido sinusoidal
      height <- dim(channel)[1]
      width <- dim(channel)[2]
      x <- seq(0, 2 * pi, length.out = width)
      y <- seq(0, 2 * pi, length.out = height)
      noise_grid <- outer(sin(x * frequency), sin(y * frequency))

      # Aplicar el ruido
      noise <- array(noise_grid * amplitude, dim = dim(channel))
      pmax(0, pmin(1, channel + noise))
    }
  ),
  salt_pepper = list(
    generator = function(channel, params) {
      # Proporción de píxeles afectados por el ruido de sal y pimienta
      epsilon <- params$epsilon %||% 0.2

      # Generación de ruido
      noise <- matrix(sample(c(0, 1, NA), length(channel), replace = TRUE, prob = c(epsilon / 2, epsilon / 2, 1 - epsilon)),
        nrow = dim(channel)[1], ncol = dim(channel)[2]
      )
      channel[!is.na(noise)] <- noise[!is.na(noise)]
      channel
    }
  ),
  gamma = list(
    generator = function(channel, params) {
      # Ruido multiplicativo gamma con parámetro de dispersión
      looks <- params$looks %||% 2
      noise <- array(rgamma(length(channel), shape = looks, scale = 1 / looks), dim = dim(channel))
      pmax(0, pmin(1, channel * noise))
    }
  ),
  uniform_multiplicative = list(
    generator = function(channel, params) {
      # Ruido multiplicativo uniforme
      looks <- params$looks %||% 2
      noise_channel <- SpatialPack::imnoise(
        img = channel,
        type = "speckle",
        looks = looks
      )
      pmax(0, pmin(1, noise_channel))
    }
  )
)

# Función para añadir ruido a una imagen
add_noise_to_image <- function(image_name, noise_type, noise_params = list(),plot=FALSE) {
  # Verificar si la imagen existe en la lista
  if (!image_name %in% names(images)) {
    stop("La imagen con este nombre no se encuentra en la lista 'images'")
  }

  # Verificar el tipo de ruido
  if (!noise_type %in% names(NOISE_TYPES)) {
    stop(
      "El tipo de ruido es desconocido. Tipos disponibles: ",
      paste(names(NOISE_TYPES), collapse = ", ")
    )
  }

  # Obtener la imagen original de la lista
  original_image <- images[[image_name]]

  # Convertir la imagen a un array si es necesario
  image_array <- as.array(original_image)

  # Aplicar ruido a cada canal
  noisy_channels <- lapply(1:3, function(i) {
    channel <- image_array[, , i]
    NOISE_TYPES[[noise_type]]$generator(channel, noise_params)
  })

  # Crear la imagen con ruido
  noisy_image_array <- array(
    unlist(noisy_channels),
    dim = dim(image_array)
  )

 # Visualizar si se ha indicado
  if (plot == TRUE){
  layout(matrix(1:2, 1, 2))
  plot(Image(original_image, colormode = "Color"))
  title("Original")
  plot(Image((noisy_image_array), colormode = "Color"))
  title(paste("Ruido:", noise_type))}
  
  return(noisy_image_array)
}

```


```{r}

# Aplicar los diferentes tipos de ruido a cada imagen
#add_noise_to_image("1", "gaussian", list(std_dev = 0.3))
#add_noise_to_image("2", "sinusoidal_high", list(frequency = 25, amplitude = 0.2))
#add_noise_to_image("3", "sinusoidal_low", list(frequency = 2, amplitude = 0.2))
#add_noise_to_image("4", "salt_pepper", list(epsilon = 0.1))
#add_noise_to_image("5", "gamma", list(looks = 2))
#add_noise_to_image("5", "uniform_multiplicative", list(looks = 2))
```


## Función imwd
El uso de la Transformada Discreta de Wavelet (DWT) permite separar las frecuencias bajas de las frecuencias altas (que suelen contener el ruido).

Se aplica la DWT en una imagen \( f(x, y) \) de tamaño \( M \times N \) con filtros paso-bajo y paso-alto en cada dimensión:

- \( H_1 \) y \( H_2 \) son los filtros paso-bajo y paso-alto en la dirección horizontal, respectivamente.
- \( V_1 \) y \( V_2 \) son los filtros paso-bajo y paso-alto en la dirección vertical.

La DWT se descompone en cuatro sub-imágenes:

1. **Aproximación (LL):** Resultado de aplicar los filtros \( H_1 \) y \( V_1 \). Contiene las bajas frecuencias de la imagen, es decir, la versión suavizada de la imagen.
   
2. **Horizontal (LH):** Resultado de aplicar \( H_1 \) y \( V_2 \). Captura detalles horizontales, como bordes verticales.

3. **Vertical (HL):** Resultado de aplicar \( H_2 \) y \( V_1 \). Captura detalles verticales, como bordes horizontales.

4. **Diagonal (HH):** Resultado de aplicar \( H_2 \) y \( V_2 \). Captura detalles diagonales, como bordes inclinados y ruido.

La DWT 2D se expresa matemáticamente como:

$$
f_{LL}(x, y) = H_1(f(x, y)) * V_1(f(x, y))
$$

$$
f_{LH}(x, y) = H_1(f(x, y)) * V_2(f(x, y))
$$

$$
f_{HL}(x, y) = H_2(f(x, y)) * V_1(f(x, y))
$$

$$
f_{HH}(x, y) = H_2(f(x, y)) * V_2(f(x, y))
$$


Para aplicar el algoritmo de Mallat (IMWD), es necesario que la imagen tenga una forma cuadrada. Dado que muchas imágenes no son cuadradas, es necesario convertirlas antes de aplicar el algoritmo.



```{r,echo=FALSE}
gaussian_noise_5<-add_noise_to_image("5", "gaussian", list(std_dev = 0.5))
sinu_high_noise_5<-add_noise_to_image("5", "sinusoidal_high", list(frequency = 25, amplitude = 0.2))
sinu_low_noise_5<-add_noise_to_image("5", "sinusoidal_low", list(frequency = 2, amplitude = 0.2))
salt_pepper_noise_5<-add_noise_to_image("5", "salt_pepper", list(epsilon = 0.1))
gamma_noise_5<-add_noise_to_image("5", "gamma", list(looks = 2))
unif_noise_5<-add_noise_to_image("5", "uniform_multiplicative", list(looks = 2))
```


```{r,echo=FALSE}

imagen_noise <- list(gaussian_noise_5,sinu_high_noise_5,sinu_low_noise_5,salt_pepper_noise_5, gamma_noise_5, unif_noise_5)
names(imagen_noise) <- c('Noise: gaussian', 'Noise: sinusoidal_high','Noise: sinusoidal_low','Noise: salt_pepper', 
                         'Noise: gamma', 'Noise: unif')
```


**Función para hacer cuadrada la imagen.**

Se genera una función que ajusta cualquier imagen rectangular a un tamaño cuadrado, manteniendo sus proporciones originales al agregar relleno si es necesario. Esta transformación asegura que la imagen sea compatible con el algoritmo IMWD.

```{r}
hacer_cuadrada_potencia_2 <- function(imagen) {
  n_filas <- dim(imagen)[1]
  n_columnas <- dim(imagen)[2]
  
  nuevo_tamano <- max(n_filas, n_columnas)
  
  siguiente_potencia_2 <- 2^ceiling(log2(nuevo_tamano))
  
  imagen_cuadrada <- array(0, dim = c(siguiente_potencia_2, siguiente_potencia_2, dim(imagen)[3])) 
  
  imagen_cuadrada[1:n_filas, 1:n_columnas, ] <- imagen
  
  return(imagen_cuadrada)
}

```


**Cargar imagenes en la función cuadrada**

Se elige la foto con menor resolución porque, al aplicar la función a fotos con mayor cantidad de píxeles, se genera un problema con el uso de la memoria en R para cargarlas. Se aplican distintos ruidos a la  misma imagen, se presenta una foto de ejemplo con ruido gaussiano.

```{r,echo=FALSE}
fotos_cuadradas <- lapply(imagen_noise, hacer_cuadrada_potencia_2)
```


```{r,echo=FALSE}
par(mfrow = c(1, 2))  # 1 fila, 2 columnas

# Mostrar la foto original
foto_original<-hacer_cuadrada_potencia_2(images[[5]])

EBImage::display(Image(foto_original, colormode = 'Color'), method = 'r')
mtext("Imagen aumentada en potencia 2", side = 3, line = 1.5, cex = 1)

i=1

EBImage::display(Image(fotos_cuadradas[[i]], colormode = 'Color'), method = 'r')
mtext(names(fotos_cuadradas)[i], side = 3, line = 1.5, cex = 1)

#par(mfrow = c(1, 1))

```


### Umbral Universal

El umbral "universal", propuesta por Donoho y Johnstone. Esta estrategia calcula el umbral aplicado a los coeficientes de wavelet en función del tamaño de la señal y una estimación del nivel de ruido. Este enfoque tiene como objetivo establecer un umbral de manera que se eliminen los coeficientes de wavelet que corresponden al ruido, mientras se conservan aquellos que contienen la señal significativa.
La fórmula del umbral "universal" es $$ \sigma \sqrt{2 \log nd}$$ donde $\sigma$ es una estimación del ruido y *nd* es el número de coeficientes en la subbanda de detalles correspondiente a un nivel de la transformada wavelet. Este valor se obtiene accediendo a los coeficientes de la subbanda D de cada nivel.

### Umbral FDR

La tasa de falsos positivos (FDR) es una técnica estadística utilizada para controlar la tasa de falsos positivos en el proceso de selección de coeficientes relevantes, tal como se describe en el trabajo de Abramovich y Benjamini (1996). En el contexto de la reducción de ruido mediante la Transformada Wavelet, el objetivo principal de FDR es identificar y eliminar los coeficientes asociados al ruido, mientras se preservan aquellos que contienen información significativa, como bordes, texturas o detalles importantes de la imagen. Esto se logra calculando, para cada coeficiente de la transformada, la probabilidad de que dicho coeficiente sea un falso positivo, es decir, que corresponda a ruido pero sea erróneamente considerado relevante.

**Metodología**

Una vez estimado el nivel de ruido, se calcula para cada coeficiente de wavelet la probabilidad \( p \) de que ese coeficiente sea ruido, utilizando la fórmula:

\[
p = 2 \left( 1 - \Phi \left( \frac{|d|}{\text{noise.level}} \right) \right)
\]

donde:

\( |d| \) es el valor absoluto del coeficiente \( d \) de la subbanda de detalles.

\( \text{noise.level} \) es la desviación estándar de los coeficientes de esa subbanda.

\( \Phi \) es la función de distribución acumulada de la normal estándar, que nos da la probabilidad de que un valor \( d \) dado provenga del ruido (asumido como una distribución normal).

**Umbralización según FDR**

El valor calculado de \( p \) da una medida de la probabilidad de que un coeficiente sea ruido. A continuación, se define un umbral para la tasa de descubrimientos falsos, denotada por \( Q \), que establece el límite máximo aceptable para la probabilidad de falso positivo. Con un \( Q = 0.05 \), esto significa que se permitirá un máximo del 5% de coeficientes de ruido que se consideren erróneamente relevantes.

Los coeficientes cuya probabilidad \( p \) sea mayor que el umbral calculado se eliminan (se consideran ruido y se establecen a cero), mientras que aquellos con \( p \) menor que el umbral se conservan, ya que se consideran significativos (es decir, pertenecen a la señal de la imagen).


```{r,echo=FALSE}

procesar_imagen_wavelet <- function(foto, tipo = "hard", policy = "universal") {
  lwd <- lapply(1:3, function(canal) {
    imwd(foto[,,canal])  
  })
  
  # 2. Aplicamos el umbral a los coeficientes de la transformada wavelet
  lwd_threshold <- lapply(lwd, function(canal_wd) {
    niveles <- canal_wd$nlevels
    wavethresh::threshold(canal_wd, levels = 3:(niveles-1), type = tipo, policy = policy,by_level=TRUE,compression=FALSE)
  })
  # 3. Aplicamos la transformada wavelet inversa a cada canal umbralizado
  ilwd <- lapply(lwd_threshold, function(canal_umbralizado) {
    wavethresh::imwr(canal_umbralizado)  # Transformada wavelet inversa
  })
  
  # 4. Reconstruir la imagen combinando los tres canales procesados
  imagen_reconstruida <- abind::abind(ilwd[[1]], ilwd[[2]], ilwd[[3]], along = 3)
    imagen <- Image(imagen_reconstruida, colormode = 'Color')
  
  return(imagen)
}
```



```{r,echo=FALSE}

#for(i in c(1:5)){
#prueba<-procesar_imagen_wavelet(fotos_cuadradas[[i]], tipo = "hard", policy = #"universal")
#EBImage::display(prueba[1:1600,1:1000,], method = 'r', title = 'Imagen Wavelet sin #ruido')
#mtext(names(fotos_cuadradas)[i], side = 3, line = 3.2, cex = 1)

#}
```


```{r,echo=FALSE}
suppressMessages(library(EBImage))

library(magick)
imprimir<-function(i){
# Crear la imagen original (con ruido)
ruido1 <- Image(fotos_cuadradas[[i]], colormode = 'Color')
img_raster <- as.raster(ruido1)
img_magick1 <- image_read(img_raster)

# Recortar la imagen a 1300x1200 desde la esquina superior izquierda
img_magick1_recortada <- image_crop(img_magick1, "1600x1060+10+10")

# Dibujar el título sobre la imagen recortada
img_magick1_recortada <- image_draw(img_magick1_recortada)
text(x = 220, y = 20, labels = paste0(names(fotos_cuadradas)[i]), col = "white", cex = 4)  # Ajusta la posición y el tamaño
dev.off()  # Termina de dibujar en la imagen

# Puedes continuar con el mismo proceso para las otras imágenes
# Recortar las imágenes procesadas y añadirles títulos

ruido1_universal <- procesar_imagen_wavelet(fotos_cuadradas[[i]], tipo = "hard", policy = "universal")
img_raster <- as.raster(ruido1_universal)
img_magick2 <- image_read(img_raster)

# Recortar la imagen procesada
img_magick2_recortada <- image_crop(img_magick2, "1600x1060+10+10")

# Dibujar el título sobre la imagen recortada
img_magick2_recortada <- image_draw(img_magick2_recortada)
text(x = 220, y = 20, labels = "Wavelet - Universal", col = "white", cex = 4) 
dev.off()

ruido1_fdr <- procesar_imagen_wavelet(fotos_cuadradas[[i]], tipo = "hard", policy = "fdr")
img_raster <- as.raster(ruido1_fdr)
img_magick3 <- image_read(img_raster)

# Recortar la imagen procesada
img_magick3_recortada <- image_crop(img_magick3, "1600x1060+10+10")

# Dibujar el título sobre la imagen recortada
img_magick3_recortada <- image_draw(img_magick3_recortada)
text(x = 220, y = 20, labels = "Wavelet - FDR", col = "white", cex = 4) 
dev.off()

# Combinar las tres imágenes recortadas
imagen_combinada_recortada <- image_append(c(img_magick1_recortada, img_magick2_recortada, img_magick3_recortada))

# Mostrar la imagen combinada recortada
return(imagen_combinada_recortada)
}
```

Se observa que el umbral FDR podría ofrecer una ligera mejora en la eliminación de ruido en comparación con el umbral Universal. Esto se debe a que el FDR estima la probabilidad de que un coeficiente de wavelet provenga del ruido, basándose en la distribución normal. Al asumir que el ruido sigue una distribución gaussiana, el FDR puede ajustar el umbral de manera más dinámica, lo que le permite identificar y eliminar los coeficientes ruidosos con mayor precisión, al tiempo que preserva los detalles relevantes de la imagen. En cambio, el umbral Universal utiliza un umbral fijo basado en el tamaño de la señal, lo que no captura completamente la variabilidad del ruido. Como resultado, el FDR podría ofrecer una eliminación de ruido más adaptativa, ayudando a preservar mejor los detalles de la imagen, aunque la diferencia en la práctica no siempre sea marcadamente significativa.

Eliminar Ruido Gaussiano

```{r,echo=FALSE}
suppressMessages(imprimir(1))
```

                         
Eliminar Ruido Sinusoidal high 

```{r,echo=FALSE}
suppressMessages(imprimir(2))
```

Eliminar Ruido Sinusoidal low 
```{r,echo=FALSE}
suppressMessages(imprimir(3))
```

Eliminar Ruido Salt and pepper 
```{r,echo=FALSE}
suppressMessages(imprimir(4))
```

Eliminar Ruido uniforme 
```{r,echo=FALSE}
suppressMessages(imprimir(5))
```


Eliminar  Ruido gamma 
```{r,echo=FALSE}
suppressMessages(imprimir(6))
```



```{r,echo=FALSE}
library(magick)

imprimir_ajustes <- function(i) {
  
  # Crear la imagen original (con ruido)
  ruido1 <- Image(fotos_cuadradas[[i]], colormode = 'Color')
  img_raster <- as.raster(ruido1)
  img_magick1 <- image_read(img_raster)
  
  # Recortar la imagen a 1600x1060 desde la esquina superior izquierda
  img_magick1_recortada <- image_crop(img_magick1, "1600x1060+10+10")
  
  # Dibujar el título sobre la imagen recortada
  img_magick1_recortada <- image_draw(img_magick1_recortada)
  text(x = 200, y = 20, labels = paste0(names(fotos_cuadradas)[i]), col = "white", cex = 3.5)  
  dev.off()  
  
  # Procesar imagen con filtro Wavelet FDR
  ruido1_fdr <- procesar_imagen_wavelet(fotos_cuadradas[[i]], tipo = "hard", policy = "fdr")
  img_raster <- as.raster(ruido1_fdr)
  img_magick3 <- image_read(img_raster)
  img_magick3_recortada <- image_crop(img_magick3, "1600x1060+10+10")
  img_magick_recortada <- image_crop(img_magick3, "1600x1060+10+10")

  # Dibujar título "Wavelet - FDR" sobre la imagen recortada
  img_magick3_recortada <- image_draw(img_magick3_recortada)
  text(x = 200, y = 20, labels = "Wavelet - FDR", col = "white", cex = 3.5)  
  dev.off()  # Termina de dibujar en la imagen
  
  # Aplicar filtro de kernel paso alto
  kernel_paso_alto <- matrix(c(0, -1, 0, -1, 5, -1, 0, -1, 0), nrow = 3, ncol = 3)
  filtrada_alto <- image_convolve(img_magick_recortada, kernel_paso_alto)
  
  # Agregar título "Filtro Alto" sobre la imagen filtrada con el filtro de paso alto
  filtrada_alto <- image_draw(filtrada_alto)
  text(x = 200, y = 20, labels = "Filtro Alto", col = "white", cex = 3.5)  # Título "Filtro Alto"
  dev.off()  # Termina de dibujar en la imagen
  
  # Aplicar contraste a la imagen
  concontraste <- image_contrast(img_magick_recortada)
  concontraste <- image_draw(concontraste)
  text(x = 200, y = 20, labels = "Contraste", col = "white", cex = 3.5)  # Título "Filtro Alto"
  dev.off() 
  
  # Combinar las tres imágenes (Wavelet, Filtro Alto, y Contraste)
  imagen_combinada_recortada <- image_append(c(img_magick_recortada3, filtrada_alto, concontraste))
  
  # Mostrar la imagen combinada recortada
  return(imagen_combinada_recortada)
}

```



```{r,echo=FALSE}
#suppressMessages(imprimir_ajustes(1))
```

```{r,echo=FALSE}
#suppressMessages(imprimir_ajustes(2))
```

```{r,echo=FALSE}
#suppressMessages(imprimir_ajustes(3))
```

```{r,echo=FALSE}
#suppressMessages(imprimir_ajustes(4))
```

```{r,echo=FALSE}
#suppressMessages(imprimir_ajustes(5))
```

```{r,echo=FALSE}
#suppressMessages(imprimir_ajustes(6))
```





## Función denoise...

# Conclusiones
